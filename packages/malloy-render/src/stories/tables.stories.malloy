source: products is duckdb.table("static/data/products.parquet") extend {

  #(story)
  view: products_table is {
    select: *
    limit: 1000
    order_by: id desc
  }

  #(story)
  view: long_column is {
    select:
      brand,
      # column {width=lg}
      name
      # column {width=200 word_break=break_all }
      f is 'asdfasdfasdfasdfasdfasdflkahdfsgoaisdfoijadsfgoiahjosdijgaodfsgijao;sdijfgoaidjsgaodsigjao;dsfgija;odfigjoaisdfj'
  }

  # bar_chart
  view: category_bar is {
    group_by: category
    aggregate: avg_retail is retail_price.avg()
  }

  #(story)
  view: simple_nested is {
    group_by: category
    aggregate: avg_retail is retail_price.avg()
    limit: 2
    nest:
      nested_column_1 is {
        group_by: brand
        aggregate: avg_retail is retail_price.avg()
        limit: 10
      },
      # list_detail
      nested_column_2 is {
        group_by: brand
        aggregate: avg_retail is retail_price.avg()
        limit: 10
      }
      another_nested is {
        group_by: department
        aggregate: avg_retail is retail_price.avg()
        nest:
          deeply_nested is {
            group_by: `sku`
            aggregate: total_cost is cost.sum()
            limit: 3
          }
        limit: 5
      }
  }

  #(story)
  view: nested is {
    group_by: category
    aggregate: avg_retail is retail_price.avg()
    nest:
      nested_column_1 is {
        group_by: brand
        aggregate: avg_retail is retail_price.avg()
        limit: 10
      }
      another_nested is {
        group_by: department
        aggregate: avg_retail is retail_price.avg()
        nest:
          deeply_nested is {
            group_by: `sku`
            aggregate: total_cost is cost.sum()
            limit: 3
          }
        limit: 5
      }
      record is {
        nest: nested_record is {
          group_by: id
          aggregate: total_cost is cost.sum()
          limit: 5
        }
      }
      another_nested2 is {
        group_by: department
        aggregate: avg_retail is retail_price.avg()
        nest: deeply_nested is {
          group_by: `sku`
          aggregate: total_cost is cost.sum()
          limit: 3
        }
        limit: 5
      }
  }

  #(story)
  view: nested_2 is {
    group_by: category
    aggregate: avg_retail is retail_price.avg()
    nest:
      by_department is {
        group_by: department
        aggregate: avg_retail is retail_price.avg()
        limit: 10
        nest: nested_column_2 is {
          group_by: brand
          aggregate: avg_retail is retail_price.avg()
          limit: 10
        }
      }
  }

  #(story)
  view: number_formats is {
    group_by: category
    aggregate:
      # currency
      avg_retail_currency is retail_price.avg()
      # percent
      avg_retail_percent is retail_price.avg()
      # number="#,##0.00"
      avg_retail_number is retail_price.avg()
      # duration
      avg_retail_duration is round(retail_price.avg())
      # duration.terse
      avg_retail_duration_terse is round(retail_price.avg())
  }

  #(story)
  # transpose
  view: date_and_time is {
    group_by:
      `@2001-02-03` is @2001-02-03
      `@2001-02-03.week` is @2001-02-03.week
      `@2001-02-03.month` is @2001-02-03.month
      `@2001-02-03.quarter` is @2001-02-03.quarter
      `@2001-02-03.year` is @2001-02-03.year
      `@2001-02-03 04:05:06.001` is @2001-02-03 04:05:06.001
      `@2001-02-03 04:05:06.001[America/Mexico_City]` is @2001-02-03 04:05:06.001[America/Mexico_City]
      `@2001-02-03 04:05:06.001.minute` is @2001-02-03 04:05:06.001.minute
      `@2001-02-03 04:05:06.001.hour` is @2001-02-03 04:05:06.001.hour
      `@2001-02-03 04:05:06.001.day` is @2001-02-03 04:05:06.001.day
      `@2001-02-03 04:05:06.001.week` is @2001-02-03 04:05:06.001.week
      `@2001-02-03 04:05:06.001.month` is @2001-02-03 04:05:06.001.month
      `@2001-02-03 04:05:06.001.quarter` is @2001-02-03 04:05:06.001.quarter
      `@2001-02-03 04:05:06.001.year` is @2001-02-03 04:05:06.001.year
      # number='yyyy'
      `@2001-02-03 tagged yyyy` is @2001-02-03
    limit: 1
  }

   #(story)
   # table.size=fill
  view: products_table_full_width is {
    select: *
    limit: 1000
    order_by: id
  }

  #(story) story="Top Level Record"
  view: record is {
    aggregate: total_cost is cost.sum()
    aggregate: avg_retail is retail_price.avg()
  }

  #(story)
  # table.size=fill
  view: nested_full_width is {
    group_by: category
    aggregate: avg_retail is retail_price.avg()
    nest:
      nested_column_1 is {
        group_by: brand
        aggregate: avg_retail is retail_price.avg()
        limit: 10
      }
      another_nested is {
        group_by: department
        aggregate: avg_retail is retail_price.avg()
        nest:
          deeply_nested is {
            group_by: `sku`
            aggregate: total_cost is cost.sum()
            limit: 3
          }
        limit: 5
      }
      record is {
        nest: nested_record is {
          group_by: id
          aggregate: total_cost is cost.sum()
          limit: 5
        }
      }
      another_nested2 is {
        group_by: department
        aggregate: avg_retail is retail_price.avg()
        nest: deeply_nested is {
          group_by: `sku`
          aggregate: total_cost is cost.sum()
          limit: 3
        }
        limit: 5
      }
  }

  measure: sales is retail_price.sum()

  #(story)
  view: perf is {
    group_by: brand
    aggregate: sales
    -- # bar_chartx
    nest: a is {
      group_by: category
      aggregate: sales
      limit: 24
    },
    nest: b is {
      group_by: category
      aggregate: sales
      # bar_chart { size=spark }
      nest: c is {
        group_by: id
        aggregate: sales
        limit: 24
      }
      limit: 5
    }
    limit: 10
  }

  #(story)
  view: record_dimension is {
    group_by: record is { brand, department }
    aggregate: sales
    limit: 10
  }

  #(story)
  view: record_array_dimension is {
    group_by: record is [{ brand, department }]
    aggregate: sales
    limit: 10
  }
}

source: null_test is duckdb.sql("select unnest([1,null,3]) as i") extend {
  #(story)
  view: null_field is {select: *}
}

source: pivot_test is duckdb.table("static/data/products.parquet") extend {
  #(story) story="Pivot Table"
  view: pivot_by_department is {
    group_by: category
    aggregate: total_cost is cost.sum()
    # pivot
    nest: by_dept is {
      group_by: department
      aggregate:
        avg_retail is retail_price.avg()
        total_cost is cost.sum()
    }
    limit: 5
  }

  #(story) story="Pivot with Explicit Dimensions"
  view: pivot_explicit_dims is {
    group_by: category
    aggregate: total_cost is cost.sum()
    // Use explicit dimensions to pivot only by department
    # pivot { dimensions=[department] }
    nest: by_dept is {
      group_by: department
      aggregate:
        avg_retail is retail_price.avg()
        total_cost is cost.sum()
    }
    limit: 3
  }

  #(story) story="Transpose Table"
  # transpose
  view: transposed is {
    group_by: category
    aggregate:
      avg_retail is retail_price.avg()
      total_cost is cost.sum()
      product_count is count()
    limit: 5
  }

  #(story) story="Transpose Limit Exceeded"
  # transpose.limit=3
  view: transpose_limit_exceeded is {
    group_by: category
    aggregate:
      avg_retail is retail_price.avg()
      total_cost is cost.sum()
    limit: 5
  }

  #(story) story="Transpose Custom Limit"
  # transpose.limit=50
  view: transpose_custom_limit is {
    group_by: brand
    aggregate:
      avg_retail is retail_price.avg()
      total_cost is cost.sum()
      product_count is count()
    limit: 30
  }
}

source: uuid is duckdb.sql("SELECT 'Sample Text' AS text_column, 42 AS number_column, '123e4567-e89b-12d3-a456-426614174000'::UUID AS uuid_column, {'name': 'foo'} AS user") extend {
  #(story)
  view: unsupported_field is {
    group_by: id is uuid_column,
    name is user.name,
  }
};

source: drilling is duckdb.sql("SELECT 1 as one") -> {
  select: one
  select: `Name with Spaces` is 1
} extend {
  join_one: joined is duckdb.sql("SELECT 2 as two") on true

  #(story) story="Drilling Dashboard"
  # dashboard
  view: drill_dash is {
    where: one::string != 'top level where'
    group_by: one is 1
    nest: a is {
      group_by: joined.two
    }
    nest: b is {
      group_by: `Name with Spaces`
    }
    nest: c is {
      aggregate: no_filters is sum(1)
    }
    nest: where_in_nest is {
      where: joined.two = 2
      group_by: one
      limit: 1
    }
    order_by: one
  }
}

// Sparse pivot data - not all names have data for all days
// This tests the "-" rendering for missing pivot cells
source: sparse_pivot is duckdb.sql(
  """
    SELECT 'Pedro' as nm, 'Monday' as dayito, 1 as loc, 2 as lac, 20 as height, 50 as apptcost, 'A' as btype
    UNION ALL SELECT 'Pedro', 'Tuesday', 1, 2, 25, 100, 'B'
    UNION ALL SELECT 'Pedro', 'Tuesday', 1, 2, 38, 200, 'A'
    UNION ALL SELECT 'Pedro', 'Wednesday', 1, 2, 45, 300, 'O'
    UNION ALL SELECT 'Sebastian', 'Thursday', 1, 2, 23, 400, 'C'
    UNION ALL SELECT 'Sebastian', 'Thursday', 1, 2, 28, 500, 'A'
    UNION ALL SELECT 'Sebastian', 'Monday', 1, 2, 35, 650, 'A'
    UNION ALL SELECT 'Sebastian', 'Monday', 1, 2, 47, 70, 'B'
    UNION ALL SELECT 'Alex', 'Tuesday', 1, 2, 23, 85, 'X'
    UNION ALL SELECT 'Alex', 'Thursday', 1, 2, 28, 42, 'P'
    UNION ALL SELECT 'Alex', 'Thursday', 1, 2, 35, 63, 'A'
    UNION ALL SELECT 'Alex', 'Monday', 1, 2, 47, 81, 'D'
    UNION ALL SELECT 'Miguel', 'Monday', 1, 2, 23, 34, 'E'
    UNION ALL SELECT 'Miguel', 'Monday', 1, 2, 28, 64, 'R'
    UNION ALL SELECT 'Miguel', 'Wednesday', 1, 2, 35, 31, 'E'
    UNION ALL SELECT 'Miguel', 'Wednesday', 1, 2, 47, 76, 'F'
  """) extend {

  #(story) story="Pivot with Sparse Data"
  view: pivot_sparse is {
    group_by: nm
    # pivot { dimensions=[dayito] }
    nest: by_day is {
      group_by: dayito
      aggregate:
        avg_height is avg(height)
        total_cost is sum(apptcost)
        max_btype is max(btype)
    }
  }
}

// Test rendering of plain arrays (not struct arrays)
// Tests string[], number[], date[], and arrays with null elements
source: array_test is duckdb.sql("""
  SELECT
    'Movie 1' as title,
    ['Action', 'Comedy'] as genres,
    ['Tom Hanks', 'Robin Wright'] as cast_names,
    [85, 92, 78] as ratings,
    [DATE '2020-01-15', DATE '2020-06-20'] as release_dates
  UNION ALL
  SELECT
    'Movie 2' as title,
    ['Drama'] as genres,
    ['Brad Pitt'] as cast_names,
    [95] as ratings,
    [DATE '2019-05-10'] as release_dates
  UNION ALL
  SELECT
    'Movie 3' as title,
    ['Action', 'Sci-Fi', 'Thriller'] as genres,
    ['Keanu Reeves', 'Carrie-Anne Moss', 'Laurence Fishburne'] as cast_names,
    [88, 91, 85, 90] as ratings,
    [DATE '1999-03-31', DATE '2003-05-15', DATE '2021-12-22'] as release_dates
""") extend {
  #(story) story="String Array Columns"
  view: string_array_column is {
    select: title, genres, cast_names
  }

  #(story) story="String Array Group By"
  view: string_array_group_by is {
    group_by: genres
    aggregate: movie_count is count()
  }

  #(story) story="Number Array Columns"
  view: number_array_column is {
    select: title, ratings
  }

  #(story) story="Date Array Columns"
  view: date_array_column is {
    select: title, release_dates
  }

  #(story) story="Mixed Array Types"
  view: mixed_array_types is {
    select: title, genres, ratings, release_dates
  }

  #(story) story="Currency Array"
  view: currency_array is {
    select:
      title
      # currency
      prices is [19.99, 24.99, 29.99]
  }
}

// Test arrays with null elements
source: array_null_test is duckdb.sql("""
  SELECT
    'Test 1' as name,
    ['a', NULL, 'b'] as string_with_null,
    [1, NULL, 3] as number_with_null,
    [DATE '2020-01-01', NULL, DATE '2020-03-01'] as date_with_null
  UNION ALL
  SELECT
    'Test 2' as name,
    [NULL, 'only'] as string_with_null,
    [NULL, 42, NULL] as number_with_null,
    [NULL] as date_with_null
""") extend {
  #(story) story="Arrays With Null Elements"
  view: arrays_with_nulls is {
    select: name, string_with_null, number_with_null, date_with_null
  }
}

// Test timestamp arrays
source: array_timestamp_test is duckdb.sql("""
  SELECT
    'Event 1' as event_name,
    [TIMESTAMP '2024-01-15 10:30:00', TIMESTAMP '2024-01-15 14:45:30'] as timestamps,
    [TIMESTAMP '2024-06-01 09:00:00', NULL, TIMESTAMP '2024-06-03 17:30:00'] as timestamps_with_null
  UNION ALL
  SELECT
    'Event 2' as event_name,
    [TIMESTAMP '2023-12-31 23:59:59'] as timestamps,
    [TIMESTAMP '2023-11-01 08:00:00', TIMESTAMP '2023-11-02 08:00:00'] as timestamps_with_null
""") extend {
  #(story) story="Timestamp Array Columns"
  view: timestamp_array_column is {
    select: event_name, timestamps, timestamps_with_null
  }
}
