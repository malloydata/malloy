source: products is duckdb.table("static/data/products.parquet") extend {
  measure: total_sales is retail_price.sum()
  measure: avg_margin is avg(retail_price - cost)
  measure:
    `Sales $` is retail_price.sum()*500
    `Cost $ really long label` is retail_price.sum()*300
  dimension: product is name
  dimension: dcId is distribution_center_id::number


  # line_chart
  view: topSellingBrands is {
    group_by: brand
    aggregate: `Sales $` is retail_price.avg()*500
    limit: 10
  }

   # line_chart
  view: topSellingBrandsSeries is {
    group_by: brand, department
    aggregate: `Sales $` is retail_price.avg()*500
    limit: 10
  }

  view: trailing_12_sales_trend is {
    group_by: brand
    aggregate: `Sales $` is retail_price.avg()*500
    limit: 12
    order_by: 1
  }

  view: baseLineData is {
    group_by: dcId
    aggregate: `Sales $`
    order_by: dcId
  }

  # dashboard { table.max_height=100000 }
  view: seriesCharts is {
    group_by: ` ` is 'Line Charts'
    # line_chart
    nest: basic is baseLineData + {
      # tooltip bar_chart.size=xs
        nest: `Top Products` is {
          group_by: product
          # currency
          aggregate: `Sales $`
          limit: 10
        }

        # tooltip
        nest: `Top 3 Categories` is {
          group_by: category
          # currency
          aggregate: `Sales $`
          limit: 3
        }
        # tooltip currency
        aggregate: `Cost $ really long label`
    }
    # line_chart.zero_baseline=false
    nest: basicNoZero is baseLineData
    # line_chart
    nest: dimensionSeries is baseLineData + {
      group_by: department
      # tooltip currency
      aggregate: `Cost $ really long label`
      # tooltip bar_chart.size=spark
      nest: departments is {
        group_by: product
        # currency
        aggregate: `Sales $`
        limit: 10
      }
    }
    # line_chart { interpolate=step }
    nest: dimensionSeriesStep is baseLineData + { group_by: department }
    # line_chart { y=['Sales $', 'Cost $ really long label']}
    nest: ySeries is  baseLineData + { aggregate: `Cost $ really long label` }
    # line_chart.zero_baseline=false
    nest: negativeData is {
      group_by: dcId, department
    aggregate: `Sales $` is retail_price.avg()-170
    order_by: dcId
    }
    # line_chart
    nest: onePoint is baseLineData + { limit: 1 }
    # line_chart { y=['Sales $', 'Cost $ really long label']}
    nest: onePointMultiY is baseLineData + { aggregate: `Cost $ really long label` limit: 1 }
    # line_chart
    nest: onePointSeries is baseLineData + { group_by: department limit: 2 }

    # line_chart
    nest: numericAxis is {
      group_by: id
      aggregate:
        `Sales $` is retail_price.avg()*500
      limit: 10
      order_by: id
    }

    # line_chart
    nest: dateAxis is {
      group_by:
        `date` is @2001-02-03 + id day
      aggregate:
        `Sales $` is retail_price.avg()*500
      limit: 20
      order_by: `date`
    }

    nest: nested is {
      group_by: category
       # line_chart
      nest: dimensionSeries is baseLineData + { group_by: department }
      limit: 10
    }
  }

  #(story)
  view: root_chart is topSellingBrands

  #(story)
  # size=fill
  view: root_chart_fill is topSellingBrands

  #(story)
  # line_chart
  view: dimension_series is baseLineData + { group_by: department }

  #(story)
  # line_chart size=fill
  view: dimension_series_fill is baseLineData + { group_by: department }

  #(story)
  view: single_nest is {
    nest: topSellingBrands
  }

  #(story)
  view: sparks is {
    group_by: category
    # currency
    aggregate: `Avg Retail` is retail_price.avg()
    nest:
    # size="spark"
    `Top Brands` is topSellingBrands
  }

  #(story)
  view: sparks_nested is {
    group_by: `Department` is department
    # currency
    aggregate: `Avg Retail` is retail_price.avg()
    nest:
      `Top 5 Categories` is {
        group_by: category
        limit: 5
        # currency
        aggregate: `Avg Retail` is retail_price.avg()
        # line_chart size="spark"
        nest: `Trailing 12mo Sales` is trailing_12_sales_trend
      }
  }

  #(story)
  view: indepenent_axis is {
    group_by: category
    aggregate: avg_retail is retail_price.avg()
    # line_chart
    nest: top_brands is {
      group_by: brand
      aggregate: avg_retail is retail_price.avg()
      limit: 10
    }
    # line_chart { y.independent }
    nest: top_brands_independent is {
      group_by: brand
      aggregate: avg_retail is retail_price.avg()
      limit: 10
    }
    limit: 5
  }

  #(story)
  view: series_dashboard is seriesCharts

  #(story)
  view: size_sheet is {
    limit: 2
    group_by: category
    nest:
    `Top Selling Brands` is topSellingBrands
    # size=spark
    spark is topSellingBrands
    # size=xs
    xs is topSellingBrands
    # size=sm
    sm is topSellingBrands
    # size=md
    md is topSellingBrands
    # size=lg
    lg is topSellingBrands
    # size=xl
    xl is topSellingBrands
    # size=2xl
    `2xl` is topSellingBrands
  }

    #(story)
  # line_chart
  view: month_truncation is {
    group_by:
      `date` is (@2001-02-03 00:00  + id day).month
    aggregate:
      `Sales $` is retail_price.avg()*500
    limit: 10
    order_by: `date`
  }

  #(story)
  view: Dates is {
    # line_chart
    nest: dateAxis is {
      group_by:
        `date` is @2001-02-03 + id day
      aggregate:
        `Sales $` is retail_price.avg()*500
      limit: 20
      order_by: `date`
    }
     # line_chart
    nest: dateAxisMany is {
      group_by:
        `date` is @2001-02-03 + id day
      aggregate:
        `Sales $` is retail_price.avg()*500
      limit: 60
      order_by: `date`
    }
    # line_chart
    nest: dateMonth is {
      group_by:
        `date` is (@2001-02-03 + id day).month
      aggregate:
        `Sales $` is retail_price.avg()*500
      limit: 60
      order_by: `date`
    }
    # line_chart
    nest: dateYear is {
      group_by:
        `date` is (@2001-02-03 + id day).year
      aggregate:
        `Sales $` is retail_price.avg()*500
      limit: 5
      order_by: `date`
    }
  }

  dimension:
    is_female is pick true when department = 'Women' else false
  measure:
    product_count_by_gender is count(id)

  #(story)
  view: boolean_x_axis is {
    nest: product_sales_by_gender is {
      group_by: is_female
      aggregate: product_count_by_gender
    }
    # line_chart
    nest: product_sales_chart is {
      group_by: is_female
      aggregate: product_count_by_gender
    }
  }

  dimension:
    `date_of_sale` is @2001-02-03 + id day
    bool_series is pick true when brand = 'Lucky Brand'
      pick false when brand = 'Calvin Klein'
      else true
    text_series_with_null is pick brand when brand = 'Lucky Brand'
      pick brand when brand = 'Calvin Klein'
      else null

  #(story)
  # line_chart
  view: time_series is {
    # x
    group_by: date_of_sale

    # series
    group_by: brand

    # y
    aggregate: `Sales $` is retail_price.avg()*500
    where: date_of_sale >= @2001-02-01 and date_of_sale < @2001-04-01
    order_by: date_of_sale
    limit: 20
  }

  #(story)
  # line_chart
  view: boolean_time_series is {
    # x
    group_by: date_of_sale

    # series
    group_by: bool_series

    # y
    aggregate: `Sales $` is retail_price.avg()*500
    where: date_of_sale >= @2001-02-01 and date_of_sale < @2001-04-01
    order_by: date_of_sale
  }

  #(story)
  # line_chart
  view: time_series_null_values is {
    # x
    group_by: date_of_sale

    # series
    group_by: text_series_with_null

    # y
    aggregate: `Sales $` is retail_price.avg()*500
    where: date_of_sale >= @2001-02-01 and date_of_sale < @2001-04-01
    order_by: date_of_sale
  }

  dimension: sale_year is year(date_of_sale)


  #(story)
  # line_chart
  view: lots_of_lines is {
    # x
    group_by: sale_year

    # series
    group_by: brand

    aggregate: total is count()

    order_by: sale_year
  }

    #(story)
  view: lots_of_lines_nested is {
    group_by: department
    # line_chart { series.limit=5 }
    nest: lots_of_lines is {
      # x
      group_by: sale_year
      # series
      group_by: brand
      aggregate: total is count()
      order_by: sale_year
    }
     # line_chart { y.independent }
    nest: lots_of_lines_independent_y is {
      # x
      group_by: sale_year
      # series
      group_by: brand
      aggregate: total is count()
      order_by: sale_year
    }
    nest: tabular is {
      group_by: sale_year
      group_by: brand
      aggregate: total is count()
      order_by: sale_year
      where: brand='Motherhood Maternity'
    }
    # line_chart { series.independent }
    nest: lots_of_lines_independent_series is {
      # x
      group_by: sale_year
      # series
      group_by: brand
      aggregate: total is count()
      order_by: sale_year
    }

  }

  #(story)
  # line_chart
  view: WithMissingDimensionValue is {
    group_by:
      # series
      department
      # x
      `date` is pick null when dcId = 3 else dcId
    aggregate:
      `Sales $` is retail_price.avg()*500
    limit: 20
    order_by: `date`
  }

  #(story)
  # line_chart
  view: auto_select_time_axis is
    {
    group_by:
      department
      `date` is @2001-02-03 + id day
    aggregate:
      `Sales $` is retail_price.avg()*500
    limit: 10
    order_by: `date`
  }
}

source: missing_data is duckdb.table("static/data/missing_data.csv") extend {

  #(story)
  # line_chart
  view: WithNullMeasureValue is {
    group_by:
      id, category
    aggregate:
      m is metric.avg()
    limit: 20
    order_by: id
  }

  #(story)
  # -line_chart table
    view: OverrideLineChartWithTable is WithNullMeasureValue + {}
}

source: random_data_nulls is duckdb.sql("""
  from (SELECT i  FROM range(0, 1000) t(i))
  select
    id: i,
    id_text: i::text,
    dim_2: floor(random()*2),
    dim_3: floor(random()*3),
    dim_6: floor(random()*6),
    dim_10: floor(random()*10),
    dim_25: floor(random()*25),
    dim_50: floor(random()*50),
    dim_100: floor(random()*100),
    dim_250: floor(random()*250),
    dim_500: floor(random()*500),
    independent_dim_2: i%2,
    independent_dim_3: i%3,
    independent_dim_6: i%6,
    independent_dim_10: i%10,
    independent_dim_25: i%25,
    independent_dim_50: i%50,
    independent_dim_100: i%100,
    independent_dim_250: i%250,
    independent_dim_500: i%500,
    null_dim_6: CASE WHEN i%6=0 THEN NULL ELSE i%6 END,
    null_measure: CASE WHEN random()<0.2 THEN NULL ELSE ceil(random()*1000) END,
    null_measure_2: CASE WHEN i%6=0 THEN NULL ELSE ceil(random()*1000) END,
  """) extend {

    view: nulls is {
      select: *
      where: null_dim_6 is null
    }

    #(story)
    # line_chart
    view: with_null_x is {
      group_by: null_dim_6
      aggregate: id.sum()
    }

    #(story)
    # line_chart
    view: with_null_series is {
      group_by:
        # series
        null_dim_6
        # x
        dim_3
      aggregate: id.sum()
    }



    #(story)
    # line_chart
    view: with_null_x_and_measure is {
      group_by: null_dim_6
      aggregate: null_measure_2.sum()
    }

    #(story)
    # line_chart
    view: with_null_x_and_measure_y_series is {
      group_by: null_dim_6
      # y
      aggregate: id.sum(), null_measure_2.sum()
    }

    #(story)
    view: with_null_x_and_measure_y_series_nested is {
      group_by: dim_2
      # line_chart
      nest: chart is {
        group_by: null_dim_6
        # y
        aggregate: id.sum(), null_measure_2.sum()
      }
    }

    #(story)
    view: with_null_series_nested is {
      group_by: dim_2
      # line_chart.series.independent
      nest: chart is {
      group_by:
        # series
        null_dim_6
        # x
        dim_3
      aggregate: id.sum()
    }
    }
  }

run: products -> { group_by: distribution_center_id}
