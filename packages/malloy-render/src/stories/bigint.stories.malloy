// Stories for testing BigInt rendering (HUGEINT, BIGINT, UBIGINT types)

// Test HUGEINT values that exceed JavaScript's MAX_SAFE_INTEGER (2^53-1 = 9007199254740991)
// Use bit shift to avoid floating point precision issues
source: hugeint_test is duckdb.sql("""
  SELECT
    (1::HUGEINT << 126) as max_hugeint,
    -(1::HUGEINT << 126) as large_negative_hugeint,
    (1::HUGEINT << 53) + 1 as just_over_max_safe,
    (1::HUGEINT << 53) as near_max_safe_integer,
    (1::HUGEINT << 63) + (1::HUGEINT << 62) as large_hugeint,
    1::HUGEINT as small_hugeint
""") extend {
  #(story) story="Single HUGEINT Value"
  view: single_hugeint is {
    select: large_hugeint
  }

  #(story) story="All HUGEINT Values"
  # transpose
  view: all_hugeints is {
    select:
      max_hugeint,
      large_negative_hugeint,
      just_over_max_safe,
      near_max_safe_integer,
      large_hugeint,
      small_hugeint
  }

  #(story) story="HUGEINT with Formatting"
  # transpose
  view: hugeint_formatted is {
    select:
      // Default: should show precise value with commas
      unformatted is large_hugeint
      // number="big" format: K/M/B/T/Q abbreviations
      # number="big"
      big_format is large_hugeint
      // Small value for currency test (lossy for large values)
      # currency
      currency_format is small_hugeint
      // Just over MAX_SAFE_INTEGER - should show precise
      precise_test is just_over_max_safe
  }
}

// Test a row of HUGEINT values in a table
source: hugeint_row_test is duckdb.sql("""
  SELECT
    'Product A' as name, (1::HUGEINT << 63) as big_value, 100::HUGEINT as small_value
  UNION ALL SELECT 'Product B', (1::HUGEINT << 64), 200::HUGEINT
  UNION ALL SELECT 'Product C', (1::HUGEINT << 65), 300::HUGEINT
  UNION ALL SELECT 'Product D', (1::HUGEINT << 66), 400::HUGEINT
  UNION ALL SELECT 'Product E', (1::HUGEINT << 67), 500::HUGEINT
""") extend {
  #(story) story="HUGEINT Row in Table"
  view: hugeint_table is {
    select: *
  }

  #(story) story="HUGEINT Aggregations"
  view: hugeint_aggregates is {
    aggregate:
      total_big is big_value.sum()
      avg_big is big_value.avg()
      max_big is big_value.max()
      min_big is big_value.min()
  }
}

// Test BIGINT (int64) values - use bit shift to create values above MAX_SAFE_INTEGER
source: bigint_test is duckdb.sql("""
  SELECT
    'Over MAX_SAFE 1' as name, (1::BIGINT << 53) + 1 as bigint_val, 1 as id
  UNION ALL SELECT 'Over MAX_SAFE 2', (1::BIGINT << 53) + 2, 2
  UNION ALL SELECT 'Large BIGINT', (1::BIGINT << 50), 3
  UNION ALL SELECT 'Negative BIGINT', -(1::BIGINT << 50), 4
""") extend {
  #(story) story="BIGINT Values"
  view: bigint_table is {
    select: *
  }
}

// Test UBIGINT (unsigned bigint) values - use bit shift to create large numbers
source: ubigint_test is duckdb.sql("""
  SELECT
    '2^63' as name, (1::UBIGINT << 63) as ubigint_val
  UNION ALL SELECT '2^62 + 2^61', (1::UBIGINT << 62) + (1::UBIGINT << 61)
  UNION ALL SELECT 'Small UBIGINT', 100::UBIGINT
""") extend {
  #(story) story="UBIGINT Values"
  view: ubigint_table is {
    select: *
  }
}

// Test line chart with bigint values - use bit shift for precision
source: bigint_chart_test is duckdb.sql("""
  SELECT 1 as x_val, (1::HUGEINT << 53) as y_val
  UNION ALL SELECT 2, (1::HUGEINT << 54)
  UNION ALL SELECT 3, (1::HUGEINT << 55)
  UNION ALL SELECT 4, (1::HUGEINT << 56)
  UNION ALL SELECT 5, (1::HUGEINT << 57)
  UNION ALL SELECT 6, (1::HUGEINT << 58)
  UNION ALL SELECT 7, (1::HUGEINT << 59)
  UNION ALL SELECT 8, (1::HUGEINT << 60)
  UNION ALL SELECT 9, (1::HUGEINT << 61)
  UNION ALL SELECT 10, (1::HUGEINT << 62)
""") extend {
  #(story) story="HUGEINT Line Chart"
  # line_chart
  view: hugeint_line is {
    group_by: x_val
    aggregate: total is y_val.sum()
    order_by: x_val
  }

  #(story) story="HUGEINT Bar Chart"
  # bar_chart
  view: hugeint_bar is {
    group_by: x_val
    aggregate: total is y_val.sum()
    order_by: x_val
  }
}
