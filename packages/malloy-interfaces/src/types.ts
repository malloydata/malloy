/*
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/*
 * Autogenerated.
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 */
export type Aggregate = {
  items: Array<AggregateOperation>;
  annotations?: Array<TagOrAnnotation>;
};
export type AggregateOperation = {
  name?: string;
  field: Field;
};
export type Annotation = {
  value: string;
};
export type AnonymousQueryInfo = {
  schema: Schema;
  annotations?: Array<Annotation>;
  definition?: Query;
  code?: string;
  location?: Location;
};
export type ArrayCell = {
  array_value: Array<Cell>;
};
export type ArrayTagValue = {
  value: Array<Tag>;
};
export type ArrayType = {
  element_type: AtomicType;
};
export enum AtomicTypeType {
  StringType = 'string_type',
  BooleanType = 'boolean_type',
  NumberType = 'number_type',
  JSONType = 'json_type',
  SQLNativeType = 'sql_native_type',
  DateType = 'date_type',
  TimestampType = 'timestamp_type',
  ArrayType = 'array_type',
  RecordType = 'record_type',
}
export type AtomicType =
  | AtomicTypeWithStringType
  | AtomicTypeWithBooleanType
  | AtomicTypeWithNumberType
  | AtomicTypeWithJSONType
  | AtomicTypeWithSQLNativeType
  | AtomicTypeWithDateType
  | AtomicTypeWithTimestampType
  | AtomicTypeWithArrayType
  | AtomicTypeWithRecordType;
export type AtomicTypeWithStringType = {
  __type: AtomicTypeType.StringType;
} & StringType;
export type AtomicTypeWithBooleanType = {
  __type: AtomicTypeType.BooleanType;
} & BooleanType;
export type AtomicTypeWithNumberType = {
  __type: AtomicTypeType.NumberType;
} & NumberType;
export type AtomicTypeWithJSONType = {
  __type: AtomicTypeType.JSONType;
} & JSONType;
export type AtomicTypeWithSQLNativeType = {
  __type: AtomicTypeType.SQLNativeType;
} & SQLNativeType;
export type AtomicTypeWithDateType = {
  __type: AtomicTypeType.DateType;
} & DateType;
export type AtomicTypeWithTimestampType = {
  __type: AtomicTypeType.TimestampType;
} & TimestampType;
export type AtomicTypeWithArrayType = {
  __type: AtomicTypeType.ArrayType;
} & ArrayType;
export type AtomicTypeWithRecordType = {
  __type: AtomicTypeType.RecordType;
} & RecordType;
export type BooleanCell = {
  boolean_value: boolean;
};
export type BooleanLiteral = {
  boolean_value: boolean;
};
export type BooleanType = {};
export enum CellType {
  StringCell = 'string_cell',
  BooleanCell = 'boolean_cell',
  DateCell = 'date_cell',
  TimestampCell = 'timestamp_cell',
  NumberCell = 'number_cell',
  JSONCell = 'json_cell',
  RecordCell = 'record_cell',
  ArrayCell = 'array_cell',
  TableCell = 'table_cell',
}
export type Cell =
  | CellWithStringCell
  | CellWithBooleanCell
  | CellWithDateCell
  | CellWithTimestampCell
  | CellWithNumberCell
  | CellWithJSONCell
  | CellWithRecordCell
  | CellWithArrayCell
  | CellWithTableCell;
export type CellWithStringCell = {__type: CellType.StringCell} & StringCell;
export type CellWithBooleanCell = {__type: CellType.BooleanCell} & BooleanCell;
export type CellWithDateCell = {__type: CellType.DateCell} & DateCell;
export type CellWithTimestampCell = {
  __type: CellType.TimestampCell;
} & TimestampCell;
export type CellWithNumberCell = {__type: CellType.NumberCell} & NumberCell;
export type CellWithJSONCell = {__type: CellType.JSONCell} & JSONCell;
export type CellWithRecordCell = {__type: CellType.RecordCell} & RecordCell;
export type CellWithArrayCell = {__type: CellType.ArrayCell} & ArrayCell;
export type CellWithTableCell = {__type: CellType.TableCell} & TableCell;
export enum DataType {
  Record = 'record',
  Table = 'table',
}
export type Data = DataWithRecord | DataWithTable;
export type DataWithRecord = {__type: DataType.Record} & RecordCell;
export type DataWithTable = {__type: DataType.Table} & Table;
export type DateCell = {
  date_value: string;
};
export type DateLiteral = {
  date_value: string;
};
export enum DateTimeframe {
  YEAR = 1,
  QUARTER = 2,
  MONTH = 3,
  WEEK = 4,
  DAY = 5,
}
export type DateType = {
  timeframe?: DateTimeframe;
};
export type DimensionInfo = {
  name: string;
  type: AtomicType;
  tag?: Tag;
  annotations?: Array<Annotation>;
};
export enum ExpressionType {
  Reference = 'reference',
  TimeTruncation = 'time_truncation',
  FilteredField = 'filtered_field',
}
export type Expression =
  | ExpressionWithReference
  | ExpressionWithTimeTruncation
  | ExpressionWithFilteredField;
export type ExpressionWithReference = {
  __type: ExpressionType.Reference;
} & Reference;
export type ExpressionWithTimeTruncation = {
  __type: ExpressionType.TimeTruncation;
} & TimeTruncationFieldReference;
export type ExpressionWithFilteredField = {
  __type: ExpressionType.FilteredField;
} & FilteredField;
export type Field = {
  expression: Expression;
  annotations?: Array<TagOrAnnotation>;
};
export enum FieldInfoType {
  Dimension = 'dimension',
  Measure = 'measure',
  Join = 'join',
  View = 'view',
}
export type FieldInfo =
  | FieldInfoWithDimension
  | FieldInfoWithMeasure
  | FieldInfoWithJoin
  | FieldInfoWithView;
export type FieldInfoWithDimension = {
  __type: FieldInfoType.Dimension;
} & DimensionInfo;
export type FieldInfoWithMeasure = {
  __type: FieldInfoType.Measure;
} & MeasureInfo;
export type FieldInfoWithJoin = {__type: FieldInfoType.Join} & JoinInfo;
export type FieldInfoWithView = {__type: FieldInfoType.View} & ViewInfo;
export type FilterStringApplication = {
  field: Reference;
  filter: string;
};
export type FilteredField = {
  reference: Reference;
  filter: WhereItem;
};
export type GroupBy = {
  items: Array<GroupByItem>;
  annotations?: Array<TagOrAnnotation>;
};
export type GroupByItem = {
  name?: string;
  field: Field;
};
export type JSONCell = {
  json_value: string;
};
export type JSONType = {};
export type JoinInfo = {
  name: string;
  schema: Schema;
  tag?: Tag;
  annotations?: Array<Annotation>;
  relationship: Relationship;
};
export type Limit = {
  limit: number;
};
export enum LiteralValueType {
  StringLiteral = 'string_literal',
  NumberLiteral = 'number_literal',
  DateLiteral = 'date_literal',
  TimestampLiteral = 'timestamp_literal',
  BooleanLiteral = 'boolean_literal',
  NullLiteral = 'null_literal',
}
export type LiteralValue =
  | LiteralValueWithStringLiteral
  | LiteralValueWithNumberLiteral
  | LiteralValueWithDateLiteral
  | LiteralValueWithTimestampLiteral
  | LiteralValueWithBooleanLiteral
  | LiteralValueWithNullLiteral;
export type LiteralValueWithStringLiteral = {
  __type: LiteralValueType.StringLiteral;
} & StringLiteral;
export type LiteralValueWithNumberLiteral = {
  __type: LiteralValueType.NumberLiteral;
} & NumberLiteral;
export type LiteralValueWithDateLiteral = {
  __type: LiteralValueType.DateLiteral;
} & DateLiteral;
export type LiteralValueWithTimestampLiteral = {
  __type: LiteralValueType.TimestampLiteral;
} & TimestampLiteral;
export type LiteralValueWithBooleanLiteral = {
  __type: LiteralValueType.BooleanLiteral;
} & BooleanLiteral;
export type LiteralValueWithNullLiteral = {
  __type: LiteralValueType.NullLiteral;
} & NullLiteral;
export type Location = {
  url: string;
  range: Range;
};
export type MeasureInfo = {
  name: string;
  type: AtomicType;
  tag?: Tag;
  annotations?: Array<Annotation>;
};
export enum ModelEntryValueType {
  Source = 'source',
  Query = 'query',
}
export type ModelEntryValue =
  | ModelEntryValueWithSource
  | ModelEntryValueWithQuery;
export type ModelEntryValueWithSource = {
  __type: ModelEntryValueType.Source;
} & SourceInfo;
export type ModelEntryValueWithQuery = {
  __type: ModelEntryValueType.Query;
} & QueryInfo;
export type ModelInfo = {
  entries: Array<ModelEntryValue>;
  tag?: Tag;
  annotations?: Array<Annotation>;
  anonymous_queries: Array<QueryInfo>;
};
export type Nest = {
  items: Array<NestItem>;
  annotations?: Array<TagOrAnnotation>;
};
export type NestItem = {
  name?: string;
  view: View;
};
export type NullLiteral = {};
export type NumberCell = {
  number_value: number;
};
export type NumberLiteral = {
  number_value: number;
};
export enum NumberSubtype {
  INTEGER = 1,
  DECIMAL = 2,
}
export type NumberType = {
  subtype?: NumberSubtype;
};
export type OrderBy = {
  items: Array<OrderByItem>;
};
export enum OrderByDirection {
  ASC = 1,
  DESC = 2,
}
export type OrderByItem = {
  field: Reference;
  direction?: OrderByDirection;
};
export type ParameterInfo = {
  name: string;
  type: AtomicType;
  default_value?: LiteralValue;
};
export type ParameterValue = {
  name: string;
  value: LiteralValue;
};
export type PipeStage = {
  refinements: Array<Refinement>;
};
export type Pipeline = {
  stages: Array<PipeStage>;
};
export type Position = {
  line: number;
  character: number;
};
export type Query = {
  source?: Reference;
  pipeline: Pipeline;
  annotations?: Array<TagOrAnnotation>;
};
export type QueryInfo = {
  name: string;
  schema: Schema;
  tag?: Tag;
  annotations?: Array<Annotation>;
  definition?: Query;
  code?: string;
  location?: Location;
};
export type Range = {
  start: Position;
  end: Position;
};
export type RecordCell = {
  record_value: Array<Cell>;
};
export type RecordType = {
  fields: Array<DimensionInfo>;
};
export type Reference = {
  name: string;
  parameters?: Array<ParameterValue>;
};
export enum RefinementType {
  Reference = 'reference',
  Segment = 'segment',
}
export type Refinement = RefinementWithReference | RefinementWithSegment;
export type RefinementWithReference = {
  __type: RefinementType.Reference;
} & Reference;
export type RefinementWithSegment = {__type: RefinementType.Segment} & Segment;
export enum Relationship {
  ONE = 1,
  MANY = 2,
  CROSS = 3,
}
export type Result = {
  data?: Data;
  schema: Schema;
  sql?: string;
};
export type Row = {
  cells: Array<Cell>;
};
export type SQLNativeType = {
  sql_type?: string;
};
export type Schema = {
  fields: Array<FieldInfo>;
};
export type Segment = {
  operations: Array<ViewOperation>;
};
export type SourceInfo = {
  name: string;
  schema: Schema;
  tag?: Tag;
  annotations?: Array<Annotation>;
  parameters?: Array<ParameterInfo>;
};
export type StringCell = {
  string_value: string;
};
export type StringLiteral = {
  string_value: string;
};
export type StringTagValue = {
  value: string;
};
export type StringType = {};
export type Table = {
  rows: Array<Row>;
};
export type TableCell = {
  table_value: Table;
};
export type Tag = {
  prefix?: string;
  value?: TagValue;
  properties?: Array<TagProperty>;
};
export enum TagOrAnnotationType {
  Tag = 'tag',
  Annotation = 'annotation',
}
export type TagOrAnnotation =
  | TagOrAnnotationWithTag
  | TagOrAnnotationWithAnnotation;
export type TagOrAnnotationWithTag = {__type: TagOrAnnotationType.Tag} & Tag;
export type TagOrAnnotationWithAnnotation = {
  __type: TagOrAnnotationType.Annotation;
} & Annotation;
export type TagProperty = {
  name: string;
  value: Tag;
};
export enum TagValueType {
  StringValue = 'string_value',
  ArrayValue = 'array_value',
}
export type TagValue = TagValueWithStringValue | TagValueWithArrayValue;
export type TagValueWithStringValue = {
  __type: TagValueType.StringValue;
} & StringTagValue;
export type TagValueWithArrayValue = {
  __type: TagValueType.ArrayValue;
} & ArrayTagValue;
export type TimeTruncationFieldReference = {
  reference: Reference;
  truncation: TimestampTimeframe;
};
export type TimestampCell = {
  timestamp_value: string;
};
export type TimestampLiteral = {
  timestamp_value: string;
};
export enum TimestampTimeframe {
  YEAR = 1,
  QUARTER = 2,
  MONTH = 3,
  WEEK = 4,
  DAY = 5,
  HOUR = 6,
  MINUTE = 7,
  SECOND = 8,
}
export type TimestampType = {
  timeframe?: TimestampTimeframe;
};
export type View = {
  pipeline: Pipeline;
  annotations?: Array<TagOrAnnotation>;
};
export type ViewInfo = {
  name: string;
  schema: Schema;
  tag?: Tag;
  annotations?: Array<Annotation>;
  definition?: View;
};
export enum ViewOperationType {
  GroupBy = 'group_by',
  Aggregate = 'aggregate',
  OrderBy = 'order_by',
  Limit = 'limit',
  Where = 'where',
  Nest = 'nest',
}
export type ViewOperation =
  | ViewOperationWithGroupBy
  | ViewOperationWithAggregate
  | ViewOperationWithOrderBy
  | ViewOperationWithLimit
  | ViewOperationWithWhere
  | ViewOperationWithNest;
export type ViewOperationWithGroupBy = {
  __type: ViewOperationType.GroupBy;
} & GroupBy;
export type ViewOperationWithAggregate = {
  __type: ViewOperationType.Aggregate;
} & Aggregate;
export type ViewOperationWithOrderBy = {
  __type: ViewOperationType.OrderBy;
} & OrderBy;
export type ViewOperationWithLimit = {__type: ViewOperationType.Limit} & Limit;
export type ViewOperationWithWhere = {__type: ViewOperationType.Where} & Where;
export type ViewOperationWithNest = {__type: ViewOperationType.Nest} & Nest;
export type Where = {
  items: Array<WhereItem>;
};
export enum WhereItemType {
  FilterString = 'filter_string',
}
export type WhereItem = WhereItemWithFilterString;
export type WhereItemWithFilterString = {
  __type: WhereItemType.FilterString;
} & FilterStringApplication;
