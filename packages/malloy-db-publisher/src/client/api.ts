/* tslint:disable */
/* eslint-disable */
/**
 * Malloy Publisher - Semantic Model Serving API
 * The Malloy Publisher - Semantic Model Serving API serves Malloy packages.  A Malloy package is a directory of Malloy models (.malloy files), Malloy notebooks (.malloynb files), and embedded datbases (.parque files) with a malloy-publisher.json manifest at the package\'s root directory. For example, see the Malloy samples packages (https://github.com/malloydata/malloy-samples) repo.
 *
 * The version of the OpenAPI document: v0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface About
 */
export interface About {
    /**
     * Readme markdown.
     * @type {string}
     * @memberof About
     */
    'readme'?: string;
}
/**
 * 
 * @export
 * @interface BigqueryConnection
 */
export interface BigqueryConnection {
    /**
     * 
     * @type {string}
     * @memberof BigqueryConnection
     */
    'defaultProjectId'?: string;
    /**
     * 
     * @type {string}
     * @memberof BigqueryConnection
     */
    'billingProjectId'?: string;
    /**
     * 
     * @type {string}
     * @memberof BigqueryConnection
     */
    'location'?: string;
    /**
     * 
     * @type {string}
     * @memberof BigqueryConnection
     */
    'serviceAccountKeyJson'?: string;
    /**
     * 
     * @type {string}
     * @memberof BigqueryConnection
     */
    'maximumBytesBilled'?: string;
    /**
     * 
     * @type {string}
     * @memberof BigqueryConnection
     */
    'queryTimeoutMilliseconds'?: string;
}
/**
 * Malloy model def and result data.  Malloy model def and result data is Malloy version depdendent.
 * @export
 * @interface CompiledModel
 */
export interface CompiledModel {
    /**
     * Model\'s package Name
     * @type {string}
     * @memberof CompiledModel
     */
    'packageName'?: string;
    /**
     * Model\'s relative path in its package directory.
     * @type {string}
     * @memberof CompiledModel
     */
    'path'?: string;
    /**
     * Type of malloy model file -- source file or notebook file.
     * @type {string}
     * @memberof CompiledModel
     */
    'type'?: CompiledModelTypeEnum;
    /**
     * Version of the Malloy compiler that generated the model def and results fields.
     * @type {string}
     * @memberof CompiledModel
     */
    'malloyVersion'?: string;
    /**
     * Data style for rendering query results.
     * @type {string}
     * @memberof CompiledModel
     */
    'dataStyles'?: string;
    /**
     * Malloy model def.
     * @type {string}
     * @memberof CompiledModel
     */
    'modelDef'?: string;
    /**
     * Array of model sources.
     * @type {Array<Source>}
     * @memberof CompiledModel
     */
    'sources'?: Array<Source>;
    /**
     * 
     * @type {Array<Query>}
     * @memberof CompiledModel
     */
    'queries'?: Array<Query>;
    /**
     * Array of notebook cells.
     * @type {Array<NotebookCell>}
     * @memberof CompiledModel
     */
    'notebookCells'?: Array<NotebookCell>;
}

export const CompiledModelTypeEnum = {
    Source: 'source',
    Notebook: 'notebook'
} as const;

export type CompiledModelTypeEnum = typeof CompiledModelTypeEnum[keyof typeof CompiledModelTypeEnum];

/**
 * 
 * @export
 * @interface Connection
 */
export interface Connection {
    /**
     * 
     * @type {string}
     * @memberof Connection
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Connection
     */
    'type'?: ConnectionTypeEnum;
    /**
     * 
     * @type {ConnectionAttributes}
     * @memberof Connection
     */
    'attributes'?: ConnectionAttributes;
    /**
     * 
     * @type {PostgresConnection}
     * @memberof Connection
     */
    'postgresConnection'?: PostgresConnection;
    /**
     * 
     * @type {BigqueryConnection}
     * @memberof Connection
     */
    'bigqueryConnection'?: BigqueryConnection;
    /**
     * 
     * @type {SnowflakeConnection}
     * @memberof Connection
     */
    'snowflakeConnection'?: SnowflakeConnection;
    /**
     * 
     * @type {TrinoConnection}
     * @memberof Connection
     */
    'trinoConnection'?: TrinoConnection;
}

export const ConnectionTypeEnum = {
    Postgres: 'postgres',
    Bigquery: 'bigquery',
    Snowflake: 'snowflake',
    Trino: 'trino'
} as const;

export type ConnectionTypeEnum = typeof ConnectionTypeEnum[keyof typeof ConnectionTypeEnum];

/**
 * 
 * @export
 * @interface ConnectionAttributes
 */
export interface ConnectionAttributes {
    /**
     * 
     * @type {string}
     * @memberof ConnectionAttributes
     */
    'dialectName'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ConnectionAttributes
     */
    'isPool'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ConnectionAttributes
     */
    'canPersist'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ConnectionAttributes
     */
    'canStream'?: boolean;
}
/**
 * An in-memory DuckDB database embedded in the package.
 * @export
 * @interface Database
 */
export interface Database {
    /**
     * Database\'s relative path in its package directory.
     * @type {string}
     * @memberof Database
     */
    'path'?: string;
    /**
     * Size of the embedded database in bytes.
     * @type {number}
     * @memberof Database
     */
    'size'?: number;
    /**
     * Type of database.
     * @type {string}
     * @memberof Database
     */
    'type'?: DatabaseTypeEnum;
}

export const DatabaseTypeEnum = {
    Embedded: 'embedded',
    Materialized: 'materialized'
} as const;

export type DatabaseTypeEnum = typeof DatabaseTypeEnum[keyof typeof DatabaseTypeEnum];

/**
 * Malloy model def and result data.  Malloy model def and result data is Malloy version depdendent.
 * @export
 * @interface Model
 */
export interface Model {
    /**
     * Model\'s package Name
     * @type {string}
     * @memberof Model
     */
    'packageName'?: string;
    /**
     * Model\'s relative path in its package directory.
     * @type {string}
     * @memberof Model
     */
    'path'?: string;
    /**
     * Type of malloy model file -- source file or notebook file.
     * @type {string}
     * @memberof Model
     */
    'type'?: ModelTypeEnum;
}

export const ModelTypeEnum = {
    Source: 'source',
    Notebook: 'notebook'
} as const;

export type ModelTypeEnum = typeof ModelTypeEnum[keyof typeof ModelTypeEnum];

/**
 * 
 * @export
 * @interface ModelError
 */
export interface ModelError {
    /**
     * 
     * @type {string}
     * @memberof ModelError
     */
    'code'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelError
     */
    'message'?: string;
}
/**
 * Notebook cell.
 * @export
 * @interface NotebookCell
 */
export interface NotebookCell {
    /**
     * Type of notebook cell.
     * @type {string}
     * @memberof NotebookCell
     */
    'type'?: NotebookCellTypeEnum;
    /**
     * Text contents of the notebook cell.
     * @type {string}
     * @memberof NotebookCell
     */
    'text'?: string;
    /**
     * Name of query, if this is a named query.  Otherwise, empty.
     * @type {string}
     * @memberof NotebookCell
     */
    'queryName'?: string;
    /**
     * Malloy query results. Populated only if a code cell.
     * @type {string}
     * @memberof NotebookCell
     */
    'queryResult'?: string;
}

export const NotebookCellTypeEnum = {
    Markdown: 'markdown',
    Code: 'code'
} as const;

export type NotebookCellTypeEnum = typeof NotebookCellTypeEnum[keyof typeof NotebookCellTypeEnum];

/**
 * 
 * @export
 * @interface Package
 */
export interface Package {
    /**
     * Package name.
     * @type {string}
     * @memberof Package
     */
    'name'?: string;
    /**
     * Package description.
     * @type {string}
     * @memberof Package
     */
    'description'?: string;
}
/**
 * 
 * @export
 * @interface PostgresConnection
 */
export interface PostgresConnection {
    /**
     * 
     * @type {string}
     * @memberof PostgresConnection
     */
    'host'?: string;
    /**
     * 
     * @type {number}
     * @memberof PostgresConnection
     */
    'port'?: number;
    /**
     * 
     * @type {string}
     * @memberof PostgresConnection
     */
    'databaseName'?: string;
    /**
     * 
     * @type {string}
     * @memberof PostgresConnection
     */
    'userName'?: string;
    /**
     * 
     * @type {string}
     * @memberof PostgresConnection
     */
    'password'?: string;
    /**
     * 
     * @type {string}
     * @memberof PostgresConnection
     */
    'connectionString'?: string;
}
/**
 * 
 * @export
 * @interface Project
 */
export interface Project {
    /**
     * Project name.
     * @type {string}
     * @memberof Project
     */
    'name'?: string;
}
/**
 * Named model query.
 * @export
 * @interface Query
 */
export interface Query {
    /**
     * Query\'s name.
     * @type {string}
     * @memberof Query
     */
    'name'?: string;
    /**
     * Annotations attached to query.
     * @type {Array<string>}
     * @memberof Query
     */
    'annotations'?: Array<string>;
}
/**
 * 
 * @export
 * @interface QueryData
 */
export interface QueryData {
    /**
     * 
     * @type {string}
     * @memberof QueryData
     */
    'data'?: string;
}
/**
 * A Malloy query\'s results, its model def, and its data styles.
 * @export
 * @interface QueryResult
 */
export interface QueryResult {
    /**
     * Data style for rendering query results.
     * @type {string}
     * @memberof QueryResult
     */
    'dataStyles'?: string;
    /**
     * Malloy model def.
     * @type {string}
     * @memberof QueryResult
     */
    'modelDef'?: string;
    /**
     * Malloy query results. Populated only if a code cell.
     * @type {string}
     * @memberof QueryResult
     */
    'queryResult'?: string;
}
/**
 * A scheduled task.
 * @export
 * @interface Schedule
 */
export interface Schedule {
    /**
     * Resource in the package that the schedule is attached to.
     * @type {string}
     * @memberof Schedule
     */
    'resource'?: string;
    /**
     * Schedule (cron format) for executing task.
     * @type {string}
     * @memberof Schedule
     */
    'schedule'?: string;
    /**
     * Action to execute.
     * @type {string}
     * @memberof Schedule
     */
    'action'?: string;
    /**
     * Connection to perform action on.
     * @type {string}
     * @memberof Schedule
     */
    'connection'?: string;
    /**
     * Timestamp in milliseconds of the last run.
     * @type {number}
     * @memberof Schedule
     */
    'lastRunTime'?: number;
    /**
     * Status of the last run.
     * @type {string}
     * @memberof Schedule
     */
    'lastRunStatus'?: string;
}
/**
 * 
 * @export
 * @interface SnowflakeConnection
 */
export interface SnowflakeConnection {
    /**
     * 
     * @type {string}
     * @memberof SnowflakeConnection
     */
    'account'?: string;
    /**
     * 
     * @type {string}
     * @memberof SnowflakeConnection
     */
    'username'?: string;
    /**
     * 
     * @type {string}
     * @memberof SnowflakeConnection
     */
    'password'?: string;
    /**
     * 
     * @type {string}
     * @memberof SnowflakeConnection
     */
    'warehouse'?: string;
    /**
     * 
     * @type {string}
     * @memberof SnowflakeConnection
     */
    'database'?: string;
    /**
     * 
     * @type {string}
     * @memberof SnowflakeConnection
     */
    'schema'?: string;
    /**
     * 
     * @type {number}
     * @memberof SnowflakeConnection
     */
    'responseTimeoutMilliseconds'?: number;
}
/**
 * Model source.
 * @export
 * @interface Source
 */
export interface Source {
    /**
     * Source\'s name.
     * @type {string}
     * @memberof Source
     */
    'name'?: string;
    /**
     * Annotations attached to source.
     * @type {Array<string>}
     * @memberof Source
     */
    'annotations'?: Array<string>;
    /**
     * List of views in the source.\\
     * @type {Array<View>}
     * @memberof Source
     */
    'views'?: Array<View>;
}
/**
 * 
 * @export
 * @interface SqlSource
 */
export interface SqlSource {
    /**
     * 
     * @type {string}
     * @memberof SqlSource
     */
    'source'?: string;
}
/**
 * 
 * @export
 * @interface TableSource
 */
export interface TableSource {
    /**
     * 
     * @type {string}
     * @memberof TableSource
     */
    'source'?: string;
}
/**
 * 
 * @export
 * @interface TemporaryTable
 */
export interface TemporaryTable {
    /**
     * 
     * @type {string}
     * @memberof TemporaryTable
     */
    'table'?: string;
}
/**
 * 
 * @export
 * @interface TrinoConnection
 */
export interface TrinoConnection {
    /**
     * 
     * @type {string}
     * @memberof TrinoConnection
     */
    'server'?: string;
    /**
     * 
     * @type {number}
     * @memberof TrinoConnection
     */
    'port'?: number;
    /**
     * 
     * @type {string}
     * @memberof TrinoConnection
     */
    'catalog'?: string;
    /**
     * 
     * @type {string}
     * @memberof TrinoConnection
     */
    'schema'?: string;
    /**
     * 
     * @type {string}
     * @memberof TrinoConnection
     */
    'user'?: string;
    /**
     * 
     * @type {string}
     * @memberof TrinoConnection
     */
    'password'?: string;
}
/**
 * Named model view.
 * @export
 * @interface View
 */
export interface View {
    /**
     * View\'s name.
     * @type {string}
     * @memberof View
     */
    'name'?: string;
    /**
     * Annotations attached to view.
     * @type {Array<string>}
     * @memberof View
     */
    'annotations'?: Array<string>;
}

/**
 * ConnectionsApi - axios parameter creator
 * @export
 */
export const ConnectionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Returns a connection.
         * @param {string} projectName Name of project
         * @param {string} connectionName Name of connection
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConnection: async (projectName: string, connectionName: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectName' is not null or undefined
            assertParamExists('getConnection', 'projectName', projectName)
            // verify required parameter 'connectionName' is not null or undefined
            assertParamExists('getConnection', 'connectionName', connectionName)
            const localVarPath = `/projects/{projectName}/connections/{connectionName}`
                .replace(`{${"projectName"}}`, encodeURIComponent(String(projectName)))
                .replace(`{${"connectionName"}}`, encodeURIComponent(String(connectionName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns a query and its results.
         * @param {string} projectName Name of project
         * @param {string} connectionName Name of connection
         * @param {string} [sqlStatement] SQL statement
         * @param {string} [_options] Options
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQuerydata: async (projectName: string, connectionName: string, sqlStatement?: string, _options?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectName' is not null or undefined
            assertParamExists('getQuerydata', 'projectName', projectName)
            // verify required parameter 'connectionName' is not null or undefined
            assertParamExists('getQuerydata', 'connectionName', connectionName)
            const localVarPath = `/projects/{projectName}/connections/{connectionName}/queryData`
                .replace(`{${"projectName"}}`, encodeURIComponent(String(projectName)))
                .replace(`{${"connectionName"}}`, encodeURIComponent(String(connectionName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (sqlStatement !== undefined) {
                localVarQueryParameter['sqlStatement'] = sqlStatement;
            }

            if (_options !== undefined) {
                localVarQueryParameter['options'] = _options;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns a SQL source.
         * @param {string} projectName Name of project
         * @param {string} connectionName Name of connection
         * @param {string} [sqlStatement] SQL statement
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSqlsource: async (projectName: string, connectionName: string, sqlStatement?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectName' is not null or undefined
            assertParamExists('getSqlsource', 'projectName', projectName)
            // verify required parameter 'connectionName' is not null or undefined
            assertParamExists('getSqlsource', 'connectionName', connectionName)
            const localVarPath = `/projects/{projectName}/connections/{connectionName}/sqlSource`
                .replace(`{${"projectName"}}`, encodeURIComponent(String(projectName)))
                .replace(`{${"connectionName"}}`, encodeURIComponent(String(connectionName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (sqlStatement !== undefined) {
                localVarQueryParameter['sqlStatement'] = sqlStatement;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns a table source.
         * @param {string} projectName Name of project
         * @param {string} connectionName Name of connection
         * @param {string} [tableKey] Table key
         * @param {string} [tablePath] Table path
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTablesource: async (projectName: string, connectionName: string, tableKey?: string, tablePath?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectName' is not null or undefined
            assertParamExists('getTablesource', 'projectName', projectName)
            // verify required parameter 'connectionName' is not null or undefined
            assertParamExists('getTablesource', 'connectionName', connectionName)
            const localVarPath = `/projects/{projectName}/connections/{connectionName}/tableSource`
                .replace(`{${"projectName"}}`, encodeURIComponent(String(projectName)))
                .replace(`{${"connectionName"}}`, encodeURIComponent(String(connectionName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (tableKey !== undefined) {
                localVarQueryParameter['tableKey'] = tableKey;
            }

            if (tablePath !== undefined) {
                localVarQueryParameter['tablePath'] = tablePath;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns a temporary table.
         * @param {string} projectName Name of project
         * @param {string} connectionName Name of connection
         * @param {string} [sqlStatement] SQL statement
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTemporarytable: async (projectName: string, connectionName: string, sqlStatement?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectName' is not null or undefined
            assertParamExists('getTemporarytable', 'projectName', projectName)
            // verify required parameter 'connectionName' is not null or undefined
            assertParamExists('getTemporarytable', 'connectionName', connectionName)
            const localVarPath = `/projects/{projectName}/connections/{connectionName}/temporaryTable`
                .replace(`{${"projectName"}}`, encodeURIComponent(String(projectName)))
                .replace(`{${"connectionName"}}`, encodeURIComponent(String(connectionName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (sqlStatement !== undefined) {
                localVarQueryParameter['sqlStatement'] = sqlStatement;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns a test.
         * @param {string} projectName Name of project
         * @param {string} connectionName Name of connection
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTest: async (projectName: string, connectionName: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectName' is not null or undefined
            assertParamExists('getTest', 'projectName', projectName)
            // verify required parameter 'connectionName' is not null or undefined
            assertParamExists('getTest', 'connectionName', connectionName)
            const localVarPath = `/projects/{projectName}/connections/{connectionName}/test`
                .replace(`{${"projectName"}}`, encodeURIComponent(String(projectName)))
                .replace(`{${"connectionName"}}`, encodeURIComponent(String(connectionName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns a list of the connections in the project.
         * @param {string} projectName Name of project
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listConnections: async (projectName: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectName' is not null or undefined
            assertParamExists('listConnections', 'projectName', projectName)
            const localVarPath = `/projects/{projectName}/connections`
                .replace(`{${"projectName"}}`, encodeURIComponent(String(projectName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ConnectionsApi - functional programming interface
 * @export
 */
export const ConnectionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ConnectionsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Returns a connection.
         * @param {string} projectName Name of project
         * @param {string} connectionName Name of connection
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getConnection(projectName: string, connectionName: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Connection>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getConnection(projectName, connectionName, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConnectionsApi.getConnection']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Returns a query and its results.
         * @param {string} projectName Name of project
         * @param {string} connectionName Name of connection
         * @param {string} [sqlStatement] SQL statement
         * @param {string} [_options] Options
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getQuerydata(projectName: string, connectionName: string, sqlStatement?: string, _options?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueryData>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getQuerydata(projectName, connectionName, sqlStatement, _options, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConnectionsApi.getQuerydata']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Returns a SQL source.
         * @param {string} projectName Name of project
         * @param {string} connectionName Name of connection
         * @param {string} [sqlStatement] SQL statement
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSqlsource(projectName: string, connectionName: string, sqlStatement?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SqlSource>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSqlsource(projectName, connectionName, sqlStatement, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConnectionsApi.getSqlsource']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Returns a table source.
         * @param {string} projectName Name of project
         * @param {string} connectionName Name of connection
         * @param {string} [tableKey] Table key
         * @param {string} [tablePath] Table path
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTablesource(projectName: string, connectionName: string, tableKey?: string, tablePath?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TableSource>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTablesource(projectName, connectionName, tableKey, tablePath, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConnectionsApi.getTablesource']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Returns a temporary table.
         * @param {string} projectName Name of project
         * @param {string} connectionName Name of connection
         * @param {string} [sqlStatement] SQL statement
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTemporarytable(projectName: string, connectionName: string, sqlStatement?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TemporaryTable>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTemporarytable(projectName, connectionName, sqlStatement, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConnectionsApi.getTemporarytable']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Returns a test.
         * @param {string} projectName Name of project
         * @param {string} connectionName Name of connection
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTest(projectName: string, connectionName: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTest(projectName, connectionName, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConnectionsApi.getTest']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Returns a list of the connections in the project.
         * @param {string} projectName Name of project
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listConnections(projectName: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Connection>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listConnections(projectName, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConnectionsApi.listConnections']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ConnectionsApi - factory interface
 * @export
 */
export const ConnectionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ConnectionsApiFp(configuration)
    return {
        /**
         * 
         * @summary Returns a connection.
         * @param {string} projectName Name of project
         * @param {string} connectionName Name of connection
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConnection(projectName: string, connectionName: string, options?: RawAxiosRequestConfig): AxiosPromise<Connection> {
            return localVarFp.getConnection(projectName, connectionName, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns a query and its results.
         * @param {string} projectName Name of project
         * @param {string} connectionName Name of connection
         * @param {string} [sqlStatement] SQL statement
         * @param {string} [_options] Options
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQuerydata(projectName: string, connectionName: string, sqlStatement?: string, _options?: string, options?: RawAxiosRequestConfig): AxiosPromise<QueryData> {
            return localVarFp.getQuerydata(projectName, connectionName, sqlStatement, _options, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns a SQL source.
         * @param {string} projectName Name of project
         * @param {string} connectionName Name of connection
         * @param {string} [sqlStatement] SQL statement
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSqlsource(projectName: string, connectionName: string, sqlStatement?: string, options?: RawAxiosRequestConfig): AxiosPromise<SqlSource> {
            return localVarFp.getSqlsource(projectName, connectionName, sqlStatement, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns a table source.
         * @param {string} projectName Name of project
         * @param {string} connectionName Name of connection
         * @param {string} [tableKey] Table key
         * @param {string} [tablePath] Table path
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTablesource(projectName: string, connectionName: string, tableKey?: string, tablePath?: string, options?: RawAxiosRequestConfig): AxiosPromise<TableSource> {
            return localVarFp.getTablesource(projectName, connectionName, tableKey, tablePath, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns a temporary table.
         * @param {string} projectName Name of project
         * @param {string} connectionName Name of connection
         * @param {string} [sqlStatement] SQL statement
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTemporarytable(projectName: string, connectionName: string, sqlStatement?: string, options?: RawAxiosRequestConfig): AxiosPromise<TemporaryTable> {
            return localVarFp.getTemporarytable(projectName, connectionName, sqlStatement, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns a test.
         * @param {string} projectName Name of project
         * @param {string} connectionName Name of connection
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTest(projectName: string, connectionName: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.getTest(projectName, connectionName, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns a list of the connections in the project.
         * @param {string} projectName Name of project
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listConnections(projectName: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<Connection>> {
            return localVarFp.listConnections(projectName, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ConnectionsApi - object-oriented interface
 * @export
 * @class ConnectionsApi
 * @extends {BaseAPI}
 */
export class ConnectionsApi extends BaseAPI {
    /**
     * 
     * @summary Returns a connection.
     * @param {string} projectName Name of project
     * @param {string} connectionName Name of connection
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConnectionsApi
     */
    public getConnection(projectName: string, connectionName: string, options?: RawAxiosRequestConfig) {
        return ConnectionsApiFp(this.configuration).getConnection(projectName, connectionName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns a query and its results.
     * @param {string} projectName Name of project
     * @param {string} connectionName Name of connection
     * @param {string} [sqlStatement] SQL statement
     * @param {string} [_options] Options
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConnectionsApi
     */
    public getQuerydata(projectName: string, connectionName: string, sqlStatement?: string, _options?: string, options?: RawAxiosRequestConfig) {
        return ConnectionsApiFp(this.configuration).getQuerydata(projectName, connectionName, sqlStatement, _options, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns a SQL source.
     * @param {string} projectName Name of project
     * @param {string} connectionName Name of connection
     * @param {string} [sqlStatement] SQL statement
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConnectionsApi
     */
    public getSqlsource(projectName: string, connectionName: string, sqlStatement?: string, options?: RawAxiosRequestConfig) {
        return ConnectionsApiFp(this.configuration).getSqlsource(projectName, connectionName, sqlStatement, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns a table source.
     * @param {string} projectName Name of project
     * @param {string} connectionName Name of connection
     * @param {string} [tableKey] Table key
     * @param {string} [tablePath] Table path
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConnectionsApi
     */
    public getTablesource(projectName: string, connectionName: string, tableKey?: string, tablePath?: string, options?: RawAxiosRequestConfig) {
        return ConnectionsApiFp(this.configuration).getTablesource(projectName, connectionName, tableKey, tablePath, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns a temporary table.
     * @param {string} projectName Name of project
     * @param {string} connectionName Name of connection
     * @param {string} [sqlStatement] SQL statement
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConnectionsApi
     */
    public getTemporarytable(projectName: string, connectionName: string, sqlStatement?: string, options?: RawAxiosRequestConfig) {
        return ConnectionsApiFp(this.configuration).getTemporarytable(projectName, connectionName, sqlStatement, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns a test.
     * @param {string} projectName Name of project
     * @param {string} connectionName Name of connection
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConnectionsApi
     */
    public getTest(projectName: string, connectionName: string, options?: RawAxiosRequestConfig) {
        return ConnectionsApiFp(this.configuration).getTest(projectName, connectionName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns a list of the connections in the project.
     * @param {string} projectName Name of project
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConnectionsApi
     */
    public listConnections(projectName: string, options?: RawAxiosRequestConfig) {
        return ConnectionsApiFp(this.configuration).listConnections(projectName, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * DatabasesApi - axios parameter creator
 * @export
 */
export const DatabasesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Returns a list of relative paths to the databases embedded in the package.
         * @param {string} projectName Name of project
         * @param {string} packageName Name of package
         * @param {string} [versionId] Version ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDatabases: async (projectName: string, packageName: string, versionId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectName' is not null or undefined
            assertParamExists('listDatabases', 'projectName', projectName)
            // verify required parameter 'packageName' is not null or undefined
            assertParamExists('listDatabases', 'packageName', packageName)
            const localVarPath = `/projects/{projectName}/packages/{packageName}/databases`
                .replace(`{${"projectName"}}`, encodeURIComponent(String(projectName)))
                .replace(`{${"packageName"}}`, encodeURIComponent(String(packageName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (versionId !== undefined) {
                localVarQueryParameter['versionId'] = versionId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DatabasesApi - functional programming interface
 * @export
 */
export const DatabasesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DatabasesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Returns a list of relative paths to the databases embedded in the package.
         * @param {string} projectName Name of project
         * @param {string} packageName Name of package
         * @param {string} [versionId] Version ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listDatabases(projectName: string, packageName: string, versionId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Database>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listDatabases(projectName, packageName, versionId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DatabasesApi.listDatabases']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DatabasesApi - factory interface
 * @export
 */
export const DatabasesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DatabasesApiFp(configuration)
    return {
        /**
         * 
         * @summary Returns a list of relative paths to the databases embedded in the package.
         * @param {string} projectName Name of project
         * @param {string} packageName Name of package
         * @param {string} [versionId] Version ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDatabases(projectName: string, packageName: string, versionId?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<Database>> {
            return localVarFp.listDatabases(projectName, packageName, versionId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DatabasesApi - object-oriented interface
 * @export
 * @class DatabasesApi
 * @extends {BaseAPI}
 */
export class DatabasesApi extends BaseAPI {
    /**
     * 
     * @summary Returns a list of relative paths to the databases embedded in the package.
     * @param {string} projectName Name of project
     * @param {string} packageName Name of package
     * @param {string} [versionId] Version ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabasesApi
     */
    public listDatabases(projectName: string, packageName: string, versionId?: string, options?: RawAxiosRequestConfig) {
        return DatabasesApiFp(this.configuration).listDatabases(projectName, packageName, versionId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * DefaultApi - axios parameter creator
 * @export
 */
export const DefaultApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Returns metadata about the publisher service.
         * @param {string} projectName Name of project
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        about: async (projectName: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectName' is not null or undefined
            assertParamExists('about', 'projectName', projectName)
            const localVarPath = `/projects/{projectName}/about`
                .replace(`{${"projectName"}}`, encodeURIComponent(String(projectName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DefaultApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Returns metadata about the publisher service.
         * @param {string} projectName Name of project
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async about(projectName: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<About>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.about(projectName, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.about']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DefaultApiFp(configuration)
    return {
        /**
         * 
         * @summary Returns metadata about the publisher service.
         * @param {string} projectName Name of project
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        about(projectName: string, options?: RawAxiosRequestConfig): AxiosPromise<About> {
            return localVarFp.about(projectName, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
    /**
     * 
     * @summary Returns metadata about the publisher service.
     * @param {string} projectName Name of project
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public about(projectName: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).about(projectName, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ModelsApi - axios parameter creator
 * @export
 */
export const ModelsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Returns a Malloy model.
         * @param {string} projectName Name of project
         * @param {string} packageName Name of package.
         * @param {string} path Path to model wihin the package.
         * @param {string} [versionId] Version ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getModel: async (projectName: string, packageName: string, path: string, versionId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectName' is not null or undefined
            assertParamExists('getModel', 'projectName', projectName)
            // verify required parameter 'packageName' is not null or undefined
            assertParamExists('getModel', 'packageName', packageName)
            // verify required parameter 'path' is not null or undefined
            assertParamExists('getModel', 'path', path)
            const localVarPath = `/projects/{projectName}/packages/{packageName}/models/{path}`
                .replace(`{${"projectName"}}`, encodeURIComponent(String(projectName)))
                .replace(`{${"packageName"}}`, encodeURIComponent(String(packageName)))
                .replace(`{${"path"}}`, encodeURIComponent(String(path)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (versionId !== undefined) {
                localVarQueryParameter['versionId'] = versionId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns a list of relative paths to the models in the package.
         * @param {string} projectName Name of project
         * @param {string} packageName Name of package
         * @param {string} [versionId] Version ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listModels: async (projectName: string, packageName: string, versionId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectName' is not null or undefined
            assertParamExists('listModels', 'projectName', projectName)
            // verify required parameter 'packageName' is not null or undefined
            assertParamExists('listModels', 'packageName', packageName)
            const localVarPath = `/projects/{projectName}/packages/{packageName}/models`
                .replace(`{${"projectName"}}`, encodeURIComponent(String(projectName)))
                .replace(`{${"packageName"}}`, encodeURIComponent(String(packageName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (versionId !== undefined) {
                localVarQueryParameter['versionId'] = versionId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ModelsApi - functional programming interface
 * @export
 */
export const ModelsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ModelsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Returns a Malloy model.
         * @param {string} projectName Name of project
         * @param {string} packageName Name of package.
         * @param {string} path Path to model wihin the package.
         * @param {string} [versionId] Version ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getModel(projectName: string, packageName: string, path: string, versionId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CompiledModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getModel(projectName, packageName, path, versionId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ModelsApi.getModel']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Returns a list of relative paths to the models in the package.
         * @param {string} projectName Name of project
         * @param {string} packageName Name of package
         * @param {string} [versionId] Version ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listModels(projectName: string, packageName: string, versionId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Model>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listModels(projectName, packageName, versionId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ModelsApi.listModels']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ModelsApi - factory interface
 * @export
 */
export const ModelsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ModelsApiFp(configuration)
    return {
        /**
         * 
         * @summary Returns a Malloy model.
         * @param {string} projectName Name of project
         * @param {string} packageName Name of package.
         * @param {string} path Path to model wihin the package.
         * @param {string} [versionId] Version ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getModel(projectName: string, packageName: string, path: string, versionId?: string, options?: RawAxiosRequestConfig): AxiosPromise<CompiledModel> {
            return localVarFp.getModel(projectName, packageName, path, versionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns a list of relative paths to the models in the package.
         * @param {string} projectName Name of project
         * @param {string} packageName Name of package
         * @param {string} [versionId] Version ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listModels(projectName: string, packageName: string, versionId?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<Model>> {
            return localVarFp.listModels(projectName, packageName, versionId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ModelsApi - object-oriented interface
 * @export
 * @class ModelsApi
 * @extends {BaseAPI}
 */
export class ModelsApi extends BaseAPI {
    /**
     * 
     * @summary Returns a Malloy model.
     * @param {string} projectName Name of project
     * @param {string} packageName Name of package.
     * @param {string} path Path to model wihin the package.
     * @param {string} [versionId] Version ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModelsApi
     */
    public getModel(projectName: string, packageName: string, path: string, versionId?: string, options?: RawAxiosRequestConfig) {
        return ModelsApiFp(this.configuration).getModel(projectName, packageName, path, versionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns a list of relative paths to the models in the package.
     * @param {string} projectName Name of project
     * @param {string} packageName Name of package
     * @param {string} [versionId] Version ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModelsApi
     */
    public listModels(projectName: string, packageName: string, versionId?: string, options?: RawAxiosRequestConfig) {
        return ModelsApiFp(this.configuration).listModels(projectName, packageName, versionId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PackagesApi - axios parameter creator
 * @export
 */
export const PackagesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Returns the package metadata.
         * @param {string} projectName Name of project
         * @param {string} packageName Package name
         * @param {string} [versionId] Version ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPackage: async (projectName: string, packageName: string, versionId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectName' is not null or undefined
            assertParamExists('getPackage', 'projectName', projectName)
            // verify required parameter 'packageName' is not null or undefined
            assertParamExists('getPackage', 'packageName', packageName)
            const localVarPath = `/projects/{projectName}/packages/{packageName}`
                .replace(`{${"projectName"}}`, encodeURIComponent(String(projectName)))
                .replace(`{${"packageName"}}`, encodeURIComponent(String(packageName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (versionId !== undefined) {
                localVarQueryParameter['versionId'] = versionId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns a list of the Packages hosted on this server.
         * @param {string} projectName Name of project
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPackages: async (projectName: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectName' is not null or undefined
            assertParamExists('listPackages', 'projectName', projectName)
            const localVarPath = `/projects/{projectName}/packages`
                .replace(`{${"projectName"}}`, encodeURIComponent(String(projectName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PackagesApi - functional programming interface
 * @export
 */
export const PackagesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PackagesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Returns the package metadata.
         * @param {string} projectName Name of project
         * @param {string} packageName Package name
         * @param {string} [versionId] Version ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPackage(projectName: string, packageName: string, versionId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Package>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPackage(projectName, packageName, versionId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PackagesApi.getPackage']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Returns a list of the Packages hosted on this server.
         * @param {string} projectName Name of project
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listPackages(projectName: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Package>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listPackages(projectName, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PackagesApi.listPackages']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PackagesApi - factory interface
 * @export
 */
export const PackagesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PackagesApiFp(configuration)
    return {
        /**
         * 
         * @summary Returns the package metadata.
         * @param {string} projectName Name of project
         * @param {string} packageName Package name
         * @param {string} [versionId] Version ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPackage(projectName: string, packageName: string, versionId?: string, options?: RawAxiosRequestConfig): AxiosPromise<Package> {
            return localVarFp.getPackage(projectName, packageName, versionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns a list of the Packages hosted on this server.
         * @param {string} projectName Name of project
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPackages(projectName: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<Package>> {
            return localVarFp.listPackages(projectName, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PackagesApi - object-oriented interface
 * @export
 * @class PackagesApi
 * @extends {BaseAPI}
 */
export class PackagesApi extends BaseAPI {
    /**
     * 
     * @summary Returns the package metadata.
     * @param {string} projectName Name of project
     * @param {string} packageName Package name
     * @param {string} [versionId] Version ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PackagesApi
     */
    public getPackage(projectName: string, packageName: string, versionId?: string, options?: RawAxiosRequestConfig) {
        return PackagesApiFp(this.configuration).getPackage(projectName, packageName, versionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns a list of the Packages hosted on this server.
     * @param {string} projectName Name of project
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PackagesApi
     */
    public listPackages(projectName: string, options?: RawAxiosRequestConfig) {
        return PackagesApiFp(this.configuration).listPackages(projectName, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ProjectsApi - axios parameter creator
 * @export
 */
export const ProjectsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Returns a list of the Projects hosted on this server.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProjects: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/projects`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProjectsApi - functional programming interface
 * @export
 */
export const ProjectsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProjectsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Returns a list of the Projects hosted on this server.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listProjects(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Project>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listProjects(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectsApi.listProjects']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ProjectsApi - factory interface
 * @export
 */
export const ProjectsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProjectsApiFp(configuration)
    return {
        /**
         * 
         * @summary Returns a list of the Projects hosted on this server.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProjects(options?: RawAxiosRequestConfig): AxiosPromise<Array<Project>> {
            return localVarFp.listProjects(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProjectsApi - object-oriented interface
 * @export
 * @class ProjectsApi
 * @extends {BaseAPI}
 */
export class ProjectsApi extends BaseAPI {
    /**
     * 
     * @summary Returns a list of the Projects hosted on this server.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public listProjects(options?: RawAxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).listProjects(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * QueryresultsApi - axios parameter creator
 * @export
 */
export const QueryresultsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Returns a query and its results.
         * @param {string} projectName Name of project
         * @param {string} packageName Name of package
         * @param {string} path Path to model within the package.
         * @param {string} [query] Query string to execute on the model.  If the query is paramter is set, the queryName parameter must be empty.
         * @param {string} [sourceName] Name of the source in the model to use for queryName, search, and topValue requests.
         * @param {string} [queryName] Name of a query to execute on a source in the model.  Requires the sourceName parameter is set.  If the queryName is paramter is set, the query parameter must be empty.
         * @param {string} [versionId] Version ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        executeQuery: async (projectName: string, packageName: string, path: string, query?: string, sourceName?: string, queryName?: string, versionId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectName' is not null or undefined
            assertParamExists('executeQuery', 'projectName', projectName)
            // verify required parameter 'packageName' is not null or undefined
            assertParamExists('executeQuery', 'packageName', packageName)
            // verify required parameter 'path' is not null or undefined
            assertParamExists('executeQuery', 'path', path)
            const localVarPath = `/projects/{projectName}/packages/{packageName}/queryResults/{path}`
                .replace(`{${"projectName"}}`, encodeURIComponent(String(projectName)))
                .replace(`{${"packageName"}}`, encodeURIComponent(String(packageName)))
                .replace(`{${"path"}}`, encodeURIComponent(String(path)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (sourceName !== undefined) {
                localVarQueryParameter['sourceName'] = sourceName;
            }

            if (queryName !== undefined) {
                localVarQueryParameter['queryName'] = queryName;
            }

            if (versionId !== undefined) {
                localVarQueryParameter['versionId'] = versionId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * QueryresultsApi - functional programming interface
 * @export
 */
export const QueryresultsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = QueryresultsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Returns a query and its results.
         * @param {string} projectName Name of project
         * @param {string} packageName Name of package
         * @param {string} path Path to model within the package.
         * @param {string} [query] Query string to execute on the model.  If the query is paramter is set, the queryName parameter must be empty.
         * @param {string} [sourceName] Name of the source in the model to use for queryName, search, and topValue requests.
         * @param {string} [queryName] Name of a query to execute on a source in the model.  Requires the sourceName parameter is set.  If the queryName is paramter is set, the query parameter must be empty.
         * @param {string} [versionId] Version ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async executeQuery(projectName: string, packageName: string, path: string, query?: string, sourceName?: string, queryName?: string, versionId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueryResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.executeQuery(projectName, packageName, path, query, sourceName, queryName, versionId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['QueryresultsApi.executeQuery']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * QueryresultsApi - factory interface
 * @export
 */
export const QueryresultsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = QueryresultsApiFp(configuration)
    return {
        /**
         * 
         * @summary Returns a query and its results.
         * @param {string} projectName Name of project
         * @param {string} packageName Name of package
         * @param {string} path Path to model within the package.
         * @param {string} [query] Query string to execute on the model.  If the query is paramter is set, the queryName parameter must be empty.
         * @param {string} [sourceName] Name of the source in the model to use for queryName, search, and topValue requests.
         * @param {string} [queryName] Name of a query to execute on a source in the model.  Requires the sourceName parameter is set.  If the queryName is paramter is set, the query parameter must be empty.
         * @param {string} [versionId] Version ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        executeQuery(projectName: string, packageName: string, path: string, query?: string, sourceName?: string, queryName?: string, versionId?: string, options?: RawAxiosRequestConfig): AxiosPromise<QueryResult> {
            return localVarFp.executeQuery(projectName, packageName, path, query, sourceName, queryName, versionId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * QueryresultsApi - object-oriented interface
 * @export
 * @class QueryresultsApi
 * @extends {BaseAPI}
 */
export class QueryresultsApi extends BaseAPI {
    /**
     * 
     * @summary Returns a query and its results.
     * @param {string} projectName Name of project
     * @param {string} packageName Name of package
     * @param {string} path Path to model within the package.
     * @param {string} [query] Query string to execute on the model.  If the query is paramter is set, the queryName parameter must be empty.
     * @param {string} [sourceName] Name of the source in the model to use for queryName, search, and topValue requests.
     * @param {string} [queryName] Name of a query to execute on a source in the model.  Requires the sourceName parameter is set.  If the queryName is paramter is set, the query parameter must be empty.
     * @param {string} [versionId] Version ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryresultsApi
     */
    public executeQuery(projectName: string, packageName: string, path: string, query?: string, sourceName?: string, queryName?: string, versionId?: string, options?: RawAxiosRequestConfig) {
        return QueryresultsApiFp(this.configuration).executeQuery(projectName, packageName, path, query, sourceName, queryName, versionId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SchedulesApi - axios parameter creator
 * @export
 */
export const SchedulesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Returns a list of running schedules.
         * @param {string} projectName Name of project
         * @param {string} packageName Name of package
         * @param {string} [versionId] Version ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSchedules: async (projectName: string, packageName: string, versionId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectName' is not null or undefined
            assertParamExists('listSchedules', 'projectName', projectName)
            // verify required parameter 'packageName' is not null or undefined
            assertParamExists('listSchedules', 'packageName', packageName)
            const localVarPath = `/projects/{projectName}/packages/{packageName}/schedules`
                .replace(`{${"projectName"}}`, encodeURIComponent(String(projectName)))
                .replace(`{${"packageName"}}`, encodeURIComponent(String(packageName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (versionId !== undefined) {
                localVarQueryParameter['versionId'] = versionId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SchedulesApi - functional programming interface
 * @export
 */
export const SchedulesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SchedulesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Returns a list of running schedules.
         * @param {string} projectName Name of project
         * @param {string} packageName Name of package
         * @param {string} [versionId] Version ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listSchedules(projectName: string, packageName: string, versionId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Schedule>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listSchedules(projectName, packageName, versionId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SchedulesApi.listSchedules']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SchedulesApi - factory interface
 * @export
 */
export const SchedulesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SchedulesApiFp(configuration)
    return {
        /**
         * 
         * @summary Returns a list of running schedules.
         * @param {string} projectName Name of project
         * @param {string} packageName Name of package
         * @param {string} [versionId] Version ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSchedules(projectName: string, packageName: string, versionId?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<Schedule>> {
            return localVarFp.listSchedules(projectName, packageName, versionId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SchedulesApi - object-oriented interface
 * @export
 * @class SchedulesApi
 * @extends {BaseAPI}
 */
export class SchedulesApi extends BaseAPI {
    /**
     * 
     * @summary Returns a list of running schedules.
     * @param {string} projectName Name of project
     * @param {string} packageName Name of package
     * @param {string} [versionId] Version ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchedulesApi
     */
    public listSchedules(projectName: string, packageName: string, versionId?: string, options?: RawAxiosRequestConfig) {
        return SchedulesApiFp(this.configuration).listSchedules(projectName, packageName, versionId, options).then((request) => request(this.axios, this.basePath));
    }
}



